<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NWorkQueue.Server.Common</name>
    </assembly>
    <members>
        <member name="T:NWorkQueue.Server.Common.Extensions.ObjectExtensions">
            <summary>
            Extensions methods for use on Objects
            </summary>
        </member>
        <member name="M:NWorkQueue.Server.Common.Extensions.ObjectExtensions.ThrowIfNull(System.Object,System.String)">
            <summary>
            Throws ArgumentNullException if object is null.
            </summary>
            <param name="obj">Object to perform null check on.</param>
            <param name="name">Param name to include in exception message.</param>
        </member>
        <member name="T:NWorkQueue.Server.Common.InternalApi">
            <summary>
            Starting point for accessing all queue related APIS
            This is mostly a factory for creating Queues and Transactions.
            </summary>
            <remarks>
            Exceptions are not used unless there is an exceptional condition.  For example, if an items doesn't exist or a param is invalid, 
            this is handled without an exception.  This is mostly for speed and simplicity with the gRPC interface.
            </remarks>
        </member>
        <member name="M:NWorkQueue.Server.Common.InternalApi.#ctor(NWorkQueue.Server.Common.IStorage)">
            <summary>
            Initializes a new instance of the <see cref="T:NWorkQueue.Server.Common.InternalApi"/> class.
            </summary>
            <param name="storage">The storage implementation to use for storage of queues and messages.</param>
        </member>
        <member name="M:NWorkQueue.Server.Common.InternalApi.CreateQueue(System.String)">
            <summary>
            Creates a new queue.
            </summary>
            <param name="queueName">The name of the queue.</param>
            <returns>A Queue info object.  Note: the queueName is the stadnardized name.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.InternalApi.DeleteQueue(System.String)">
            <summary>
            Delete a queue and all messages in the queue.
            Throws an exception if Queue doesn't exist
            </summary>
            <param name="queueName">Name of the queue to delete.</param>
        </member>
        <member name="M:NWorkQueue.Server.Common.InternalApi.GetQueueInfoById(System.Int64)">
            <summary>
            Returns information about the requested queue.
            </summary>
            <param name="queueId">The ID of the queue.</param>
            <returns>QueueInfo object. Returns null if not found.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.InternalApi.GetQueueInfoByName(System.String)">
            <summary>
            Returns information about the requested queue.
            </summary>
            <param name="queueName">The Name of the queue to lookup.</param>
            <returns>QueueInfo object.  Null if not found.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.InternalApi.DeleteQueue(System.Int64)">
            <summary>
            Deletes a queue and 1) rollsback any transaction related to the queue, 2) deletes all messages in the queue.
            </summary>
            <param name="queueId">Queue id.</param>
            <returns>ValueTask.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.InternalApi.Dispose">
            <summary>
            Disposes of storage resources.
            </summary>
        </member>
        <member name="M:NWorkQueue.Server.Common.InternalApi.InitializeStorage(System.Boolean)">
            <summary>
            Creates underlying structure in the storage layer.
            </summary>
            <param name="deleteExistingData">Will delete and recreate underlying structures.</param>
            <returns>Returns ValueTask.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.InternalApi.StartTrasaction(System.Int32)">
            <summary>
            Starts a transaction used my add message and pull message.
            </summary>
            <param name="expiryTimeInMinutes">Override default expiration time.</param>
            <returns>Transaction ID.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.InternalApi.ExtendTransaction(System.Int64,System.Int32)">
            <summary>
            Extends the transaction by x number of minutes (from the current datetime).
            </summary>
            <param name="transId">The transaction to extend.</param>
            <param name="expiryTimeInMinutes">How long to extend the transaction by.</param>
            <returns>ValueTask.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.InternalApi.CommitTransaction(System.Int64)">
            <summary>
            Commits Transaction, updating all messages in transaction.
            </summary>
            <param name="transId">Transaction Id to commit.</param>
            <returns>ValueTask.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.InternalApi.RollbackTransaction(System.Int64)">
            <summary>
            Rollsback a transaction, undoing any changes to messages in the transaction.
            </summary>
            <param name="transId">The transaction ID of the transaction to rollback.</param>
            <returns>ValueTask.</returns>
        </member>
        <member name="T:NWorkQueue.Server.Common.IStorage">
            <summary>
            The interface for storing and retrieving queue information from a storage mechinism, usually a database.
            When implementing IStorage, use the StorageSqlite as an example.  There should be no business logic in
            classes that implement IStorage.
            </summary>
        </member>
        <member name="M:NWorkQueue.Server.Common.IStorage.InitializeStorage(System.Boolean)">
            <summary>
            Called when Queue process starts.  Connections to the storage should be made here, etc.
            </summary>
            <param name="deleteExistingData">Should all existing queues and messages be deleted.</param>
            <returns>ValueTask.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.IStorage.AddQueue(System.String)">
            <summary>
            Create a new Queue in storage.
            </summary>
            <param name="name">Queue name.</param>
            <returns>ValueTask.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.IStorage.DeleteQueue(System.Int64)">
            <summary>
            Delete a Queue and ALL messages in the Queue.
            </summary>
            <param name="id">Queue Id of the queue to delete.</param>
            <returns>ValueTask.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.IStorage.GetTransactionById(System.Int64)">
            <summary>
            Returns a Transaction object or null value if not found.
            </summary>
            <param name="transId">The Id of the transaction to lookup.</param>
            <returns>Transaction object or null if not found.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.IStorage.GetQueueInfoByName(System.String)">
            <summary>
            Returns the id and name of the Queue.  If no queue is found, returns null.
            </summary>
            <remarks>
            This search should be case sensitive, only use LIKE with SQLite.
            </remarks>
            <param name="name">Name of the queue to lookup.</param>
            <returns>QueueInfo containing ID and Name of queue.  Null if not found.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.IStorage.GetQueueInfoById(System.Int64)">
            <summary>
            Returns the id and name of the Queue.  If no queue is found, returns null.
            </summary>
            <remarks>
            This search should be case sensitive, only use LIKE with SQLite.
            </remarks>
            <param name="queueId">ID of the queue to lookup.</param>
            <returns>QueueInfo containing ID and Name of queue.  Null if not found.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.IStorage.StartTransaction(System.DateTime,System.DateTime)">
            <summary>
            Starts a transaction for use when adding or pulling messages.
            </summary>
            <param name="startDateTime">When the transaction started.</param>
            <param name="expiryDateTime">When the transaction will end.</param>
            <returns>Returns transaction ID.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.IStorage.ExtendTransaction(System.Int64,System.DateTime)">
            <summary>
            Extends the transaction's expiration datetime.
            </summary>
            <param name="transId">The id of the transaction to update.</param>
            <param name="expiryDateTime">The new expiration datetime.</param>
            <returns>ValueTask.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.IStorage.UpdateTransactionState(System.Int64,NWorkQueue.Common.TransactionState,System.Nullable{System.DateTime})">
            <summary>
            Update the transaction's state and end datetime.
            </summary>
            <param name="transId">The id of the transaction to update.</param>
            <param name="state">The new state of the transaction.</param>
            <param name="endDateTime">Datetime the transaction was closed (or null if not closed).</param>
            <returns>ValueTask.</returns>
        </member>
        <member name="M:NWorkQueue.Server.Common.IStorage.BeginStorageTransaction">
            <summary>
            Starts a storage (database) transaction, not a queue transaction.
            </summary>
            <remarks>
            Not all Storage classes will have internal transactions, so this can return a dummy class that performs no actions.
            </remarks>
            <returns>Returns a class represented by IStorageTransaction which can commit or rollbacl the transaction.</returns>
        </member>
        <member name="T:NWorkQueue.Server.Common.IStorageTransaction">
            <summary>
            Represents a transaction used by the storage (usually a database transaction)
            </summary>
        </member>
        <member name="M:NWorkQueue.Server.Common.IStorageTransaction.Commit">
            <summary>
            Commits the transaction, usually this reprents a database transaction
            </summary>
        </member>
        <member name="M:NWorkQueue.Server.Common.IStorageTransaction.Rollback">
            <summary>
            Rollsback the transaction, usually this reprents a database transaction
            </summary>
        </member>
        <member name="T:NWorkQueue.Server.Common.ResultCode">
            <summary>
            Result codes from internal API calls.  This currently map directly to gRPC status codes, but
            the internal api may be used with another protocol, hence it can't depend on gRPC status codes.
            Most of these are not used by the Internal API.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.Ok">
            <summary>
            Not an error; returned on success.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.Cancelled">
            <summary>
            The operation was cancelled (typically by the caller).
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.Unknown">
            <summary>
            Unknown error. An example of where this error may be returned is if a Status
            value received from another address space belongs to an error-space that is not
            known in this address space. Also errors raised by APIs that do not return enough
            error information may be converted to this error.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.InvalidArgument">
            <summary>
            Client specified an invalid argument. Note that this differs from FAILED_PRECONDITION.
            INVALID_ARGUMENT indicates arguments that are problematic regardless of the state
            of the system (e.g., a malformed file name).
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.DeadlineExceeded">
            <summary>
            Deadline expired before operation could complete. For operations that change
            the state of the system, this error may be returned even if the operation has
            completed successfully. For example, a successful response from a server could
            have been delayed long enough for the deadline to expire.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.NotFound">
            <summary>
            Some requested entity (e.g., file or directory) was not found.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.AlreadyExists">
            <summary>
            Some entity that we attempted to create (e.g., file or directory) already exists.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.PermissionDenied">
            <summary>
            The caller does not have permission to execute the specified operation. PERMISSION_DENIED
            must not be used for rejections caused by exhausting some resource (use RESOURCE_EXHAUSTED
            instead for those errors). PERMISSION_DENIED must not be used if the caller can
            not be identified (use UNAUTHENTICATED instead for those errors).
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.ResourceExhausted">
            <summary>
                Some resource has been exhausted, perhaps a per-user quota, or perhaps the entire
                file system is out of space.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.FailedPrecondition">
            <summary>
            Operation was rejected because the system is not in a state required for the
            operation's execution. For example, directory to be deleted may be non-empty,
            an rmdir operation is applied to a non-directory, etc.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.Aborted">
            <summary>
            The operation was aborted, typically due to a concurrency issue like sequencer
            check failures, transaction aborts, etc.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.OutOfRange">
            <summary>
            Operation was attempted past the valid range. E.g., seeking or reading past end
            of file.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.Unimplemented">
            <summary>
            Operation is not implemented or not supported/enabled in this service.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.Internal">
            <summary>
            Internal errors. Means some invariants expected by underlying system has been
            broken. If you see one of these errors, something is very broken.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.Unavailable">
            <summary>
            The service is currently unavailable. This is a most likely a transient condition
            and may be corrected by retrying with a backoff. Note that it is not always safe
            to retry non-idempotent operations.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.DataLoss">
            <summary>
            Unrecoverable data loss or corruption.
            </summary>
        </member>
        <member name="F:NWorkQueue.Server.Common.ResultCode.Unauthenticated">
            <summary>
            The request does not have valid authentication credentials for the operation.
            </summary>
        </member>
    </members>
</doc>
